
#Delegate, Notification, KVO 各自的优缺点

在开发ios应用的时候，我们会经常遇到一个常见的问题：在不过分耦合的前提下，controllers间怎么进行通信。

在iOS应用不断的出现三种模式来实现这种通信：

    1.代理,委托 delegation

    2.通知中心 Notification Center

    3.键值观察(key value observing) KVO


###1. 代理 - delegate

优点:

    1.严格的语法，所有能响应的事件必须在协议中有清晰的定义
    
    2.因为有严格的语法，所以编译器能帮你检查是否实现了所有应该实现的方法，不容易遗忘和出错
    
    3.使用delegate的时候，逻辑很清楚，控制流程可跟踪和识别
    
    4.在一个controller中可以定义多个协议，每个协议有不同的delegate
    
    5.能够接受调用的协议方法的返回值，意味着delegate能够提供反馈信息给controller
    
缺点:

    1.需要写的代码比较多
    
###2. 通知中心 - Notification 

有一个“Notification Center”的概念，他是一个单例对象，允许当事件发生的时候通知一些对象，满足控制器与一个任意的对象进行通信的目的，这种模式的基本特征就是接收到在该controller中发生某种事件而产生的消息，controller用一个key（通知名称），这样对于controller是匿名的，其他的使用同样地key来注册了该通知的对象能对通知的事件作出反应。

优点:

    1.实现比较简单, 不需要写多少代码
    
    2.一个对象发出的通知，多个对象能进行反应，一对多的方式实现很简单
    
缺点:

    1.编译期不会检测通知是否能被正确处理
    
    2.调试的时候，程序的工作以及控制流程难跟踪
    
    3.需要第三方来管理controller和观察者的联系
    
    4.通知发出后，发出通知的对象不能从观察者获得任何反馈。
    
###3. 键值观察 - KVO

KVO是一个对象能观察另一个对象属性的值，前两种模式更适合一个controller和其他的对象进行通信，而KVO适合任何对象监听另一个对象的改变，这是一个对象与另外一个对象保持同步的一种方法。KVO只能对属性做出反应，不会用来对方法或者动作做出反应。

有点:

    1.提供一个简单地方法来实现两个对象的同步
    
    2.能对非我们创建的对象做出反应
    
    3.用keypaths 来观察属性，因此也可以观察嵌套对象

缺点:

    1.观察的属性必须使用string来定义，因此编译器不会出现警告和检查
    
    2.对属性的重构将导致观察不可用
    
    3.复杂的“if”语句要求对象正在观察多个值，这是因为所有的观察都通过一个方法来指向
    
    
##总结

当处理属性层的消息的事件时候(监视一个属性变化的时候)，使用KVO，其他的尽量使用delegate，除非代码需要处理的东西确实很简单，那么用通知很方便。
    
    
<br />
<br />
<br />
    