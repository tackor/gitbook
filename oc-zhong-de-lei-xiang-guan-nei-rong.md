# OC 中的类方法和实例方法有什么本质区别 & 联系

* 类方法:
    
    1. 类方法属于类对象
    2. 类方法只能通过类对象调用
    3. 类方法中的self是类对象
    4. 类方法可以调用其他类方法,但不能调用实例方法
    5. 类方法不能访问成员变量
    6. 类方法中不能直接调用实例方法(又叫对象方法)
    7. 类方法是存储在元类对象的方法缓存中的
    
* 实例方法:

    1. 实例方法是属于实例对象的
    2. 实例方法只能通过实例对象调用
    3. 实例方法中的self是实例对象
    4. 实例方法中可以访问成员变量
    5. 实例方法中可以直接调用实例方法
    6. 实例方法中可以调用类方法(通过类名)
    7. 实例方法是存放在类对象的方法缓存中的
    
# OC中调用方法的过程

    * OC 是动态语言, 每个方法在运行时会被动态转为消息发送, 即:
    objc_msgSend(receiver, selector), 整个过程如下:
    
        * objc 在想一个对象发送消息时, runtime库会根据对象的isa指针找到该对象实际所属的类
        
        * 然后在该类中的方法列表以及其父类方法列表中寻找方法运行
        
        * 如果, 在最顶层的父类(一般也就NSObject) 中依然找不到对应的方法时, 程序在运行时会挂掉并抛出异常 unrecognized selector sent to XXX
        
        * 但是在这之前, objc的运行时会给出三次拯救程序崩溃的机会.
    
    补充: Runtime 铸就了Objective-C 是动态语言的特性, 使得C语言具备了面向对象那个的特性, 在程序运行期间创建, 检查, 修改类, 对象 以及对于的方法, 这些操作都可以使用runtime中的对应方法实现.
        
# OC 中想一个 nil 对象 发送消息将会怎样?

* OC中向一个nil对象发送消息是完全有效的, 只是在运行时不会有任何作用, 且如果该消息有返回值, 返回对应的默认值( 对象, 基本类型,为0)

# 对于语句NSString*obj = [[NSData alloc] init]; obj在编译时和运行时分别时什么类型的对象?

* 编译时是NSString的类型;运行时是NSData类型的对象

# id 声明的对象有什么特性?

* Id 声明的对象具有运行时的特性，即可以指向任意类型的objcetive-c的对象;








        
        
<br />
<br />
<br />

